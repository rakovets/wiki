= Введение в Web

В конце 80-х — начале 90-х годов XX-го столетия практически все системы строились по принципу *client-server*. На компьютере работника было установлено графическое (или текстовое) приложение, которое обращалось к *database* с запросами на изменение или получение данных.

Таким образом было две стороны:

1. *client* который имел какую-то логику и давал возможность пользователю что-то делать с данными
2. *server* обычно СУБД типа SQL, на котором выполнялись запросы на получение данных и их изменение

За счет возможности писать сохраненные процедуры (*Stored Procedure*) с помощью расширения для *SQL*. Это расширение описывается *ISO standard* *SQL/PSM*. Большинство СУБД на 100% реализуют этот стандарт, но некоторые СУБД имеют свои собственные *Procedural Language*:

* *PL/SQL*: *Oracle*, *DB2* (since version 9.7)
* *Transact-SQL*: Sybase* (*SAP*), *Microsoft*
* *PL/pgSQL*: *PostgreSQL*
* *SQL PL*: *DB2*

Такого рода процедуры позволяли писать достаточно сложную логику обработки данных, не перекладывая эту работу на *client*. Поэтому когда изменялась логика, то изменения необходимо было произвести ТОЛЬКО на *server* не затрагивая при этом *client application*.

Такое взаимодействие замечательно работало до тех пор, пока не появилась *ПОТРЕБНОСТЬ*.

Системы *client-server* требовали сотрудника. Если клиент хочет сделать заказ — он должен связаться с сотрудником, который занесет его заказ в *database* с помощью своего *client application*.

Достаточно прямолинейное решение — дать клиентам приложение (пусть и ограниченное) было бы слишком опрометчивым, потому что:

* необходимо разработать
* необходимо менять под потребности клиентов
* необходимо обновлять каждый раз у клиентов
* система все чаще становилась зависимой не от одной базы данных, а от многих источников информации
* клиентское приложение ходит в базу данных. Центральное хранилище “открывать” наружу — это уже не БЕЗОПАСНО.

Поэтму появились три задачи, которые стали определяющими для дальнейшего развития:

* безопасность
* клиентское приложение с возможностью обновления для сотен тысяч пользователей
* возможность принимать запросы от универсального клиента и писать логику для распределенных источников информации

== Безопасность

Вполне логичным решением было введение промежуточного звена, которое принимало запросы от клиентов, проверяло бы их и транслировало бы дальше внутрь корпоративной сети. Таким образом все хранилища будут закрыты извне. Будет только один шлюз/вход, через который будут проходить все запросы. Такой вход гораздо легче контролировать.

== Универсальный клиент

Самое очевидное решение — нужна программа, которая в *runtime* исполняет код, который в нее загружается. И этим универсальным *client* стал *browser*.

Со временем браузеры совершенствовались, язык отображения *HTML* (*Hyper Text Markup Language* — язык разметки гипертекста), становился более сложным и изощренным. Появились *JavaScript*, который мог исполнять браузер и таким образом сделать страницы более интерактивными. Начиная с версии HTML 4.0 появились *CSS* (*Cascade Style Sheets* — каскадные таблицы стилей). Потом появилась и прижилась технология *AJAX* (*Asynchronous JavaScript And XML*).

Browser может загрузить данные, отобразить их, позволить что-то ввести в текстовые поля и отправить данные на *server*.

== Сервер приложений

Он-то и должен предоставить “возможность принимать запросы от универсального клиента и писать логику для распределенных источников информации”.

В простом варианте это была обычная программа, которая ждала запросы от внешних программ. Причем в ранних версиях у такого сервера не было даже многопоточности — она просто порождала свою копию в виде отдельного процесса и передавала туда обработку запроса.

Также программа предоставляла возможность писать другие программы, которые могли быть ею запущены для исполнения запросов.


В итоге схема для решения ПОТРЕБНОСТИ выглядит следующим образом:

* *browser*, как универсальный клиент, который, по определенному протоколу обратиться к *application server* (т.е. к программе, которая умеет запускать другие программы)
* *application server* в свою очередь запустит на выполнение *program*, которая написана по определенным правилам
* *program* обработает запрос, что-то поменяет, что-то считает и отдаст результат (какие-то данные) в *browser*
* *browser* это отобразит

В итоге пришли к выводам:

* нам нужен *browser*
* нам нужна *program* для приема сетевых запросов, которая должна предоставлять возможности интегрировать в него другие *programs*, которые будут решать специализированные задачи

== *Browser* как client

*Browser* - это прикладное программное обеспечение для просмотра страниц, содержания веб-документов, компьютерных файлов и их каталогов; управления веб-приложениями; а также для решения других задач. Браузеров, на данный момент, очень много, например:

* Mozilla Firefox
* Google Chrome
* Internet Explorer
* Opera
* Apple Safari
* Амиго

== *Application server* как server

Программа, которая работает с сетевыми запросы может быть как простой, так и сложной, с большим количеством возможностей, которые необходимо изучать. Эту программу и называют *application server*. Так как *application server*  — это программа, то ее надо запускать, как обычную программу на компьютере. Эта программа предоставляет широко используемые сервисы. Уже заранее готовые и настроенные. Если говорить о Java, то упрощенно, это уже готовый набор объектов или классов, которые можно использовать. Эти объекты создает *application server* по настройкам и любая программа, которая установлена на *application server*, может их использовать.


== Взаимодействие client и server

*Client* и *server* (как и любым двум программам) необходимо научиться разговаривать друг с другом. *Server* должен понимать *request* от *client*, а *client* должен понимать *response* от *server*. Всё это и называется *protocol*. Если рассматривать это на низном уровне, то это *набор слов* (*байтов*), которые можно использовать для общения.
