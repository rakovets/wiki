=== Interface `List`

Для создания простых списков применяется интерфейс `List`, который расширяет функцональность интерфейса `Collection`. Некоторые наиболее часто используемые методы интерфейса `List`:

- `void add(int index, E obj)` добавляет в список по индексу `index` объект `obj`
- `boolean addAll(int index, Collection<? extends E> col)` добавляет в список по индексу `index` все элементы коллекции `col`. Если в результате добавления список был изменен, то возвращается `true`, иначе возвращается `false`
- `E get(int index)` возвращает объект из списка по индексу `index`
- `int indexOf(Object obj)` возвращает индекс первого вхождения объекта `obj` в список. Если объект не найден, то возвращается `-1`
- `int lastIndexOf(Object obj)` возвращает индекс последнего вхождения объекта `obj` в список. Если объект не найден, то возвращается `-1`
- `ListIterator<E> listIterator ()` возвращает объект `ListIterator` для обхода элементов списка
- `static <E> List<E> of(Object ...)` создает из набора элементов объект `List`
- `E remove(int index)` удаляет объект из списка по индексу `index`, возвращая при этом удаленный объект
- `E set(int index, E obj)` присваивает значение объекта `obj` элементу, который находится по индексу `index`
- `void sort(Comparator<? super E> comp)` сортирует список с помощью компаратора `comp`
- `List<E> subList(int start, int end)` получает набор элементов, которые находятся в списке между индексами `start` и `end`

=== `ArrayList`

По умолчанию в Java есть встроенная реализация этого интерфейса - класс `ArrayList`. Класс `ArrayList` представляет обобщенную коллекцию, которая наследует свою функциональность от класса `AbstractList` и применяет интерфейс `List`. Проще говоря, `ArrayList` представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.

`ArrayList` имеет следующие конструкторы`:

- `ArrayList()` создает пустой список
- `ArrayList(Collection <? extends E> col)` создает список, в который добавляются все элементы коллекции `col`
- `ArrayList (int capacity)` создает список, который имеет начальную емкость `capacity`

Емкость в `ArrayList` представляет размер массива, который будет использоваться для хранения объектов. При добавлении элементов фактически происходит перераспределение памяти - создание нового массива и копирование в него элементов из старого массива. Изначальное задание емкости `ArrayList` позволяет снизить подобные перераспределения памяти, тем самым повышая производительность.

Используем класс `ArrayList` и некоторые его методы в программе:

[source, java]
----
import java.util.ArrayList;

public class Program {
    public static void main(String[] args) {
        ArrayList<String> people = new ArrayList<String>();
        // добавим в список ряд элементов
        people.add("Tom");
        people.add("Alice");
        people.add("Kate");
        people.add("Sam");
        people.add(1, "Bob"); // добавляем элемент по индексу 1

        System.out.println(people.get(1));// получаем 2-й объект
        people.set(1, "Robert"); // установка нового значения для 2-го объекта

        System.out.printf("ArrayList has %d elements \n", people.size());
        for (String person : people) {
            System.out.println(person);
        }
        // проверяем наличие элемента
        if (people.contains("Tom")) {
            System.out.println("ArrayList contains Tom");
        }

        // удалим несколько объектов
        // удаление конкретного элемента
        people.remove("Robert");
        // удаление по индексу
        people.remove(0);

        Object[] peopleArray = people.toArray();
        for (Object person : peopleArray) {
            System.out.println(person);
        }
    }
}
----

Здесь объект `ArrayList` типизируется классом `String`, поэтому список будет хранить только строки. Поскольку класс `ArrayList` применяет интерфейс `Collection<E>`, то мы можем использовать методы данного интерфейса для управления объектами в списке.

Для добавления вызывается метод `add()`. С его помощью мы можем добавлять объект в конец списка. Также мы можем добавить объект на определенное место в списке. Например:

[source, java]
----
people.add("Tom") // добавит элемент в конец списка
people.add(1, "Bob") // добавит элемент на 1 позицию в списке
----

Метод `size()` позволяет узнать количество объектов в коллекции.

Проверку на наличие элемента в коллекции производится с помощью метода `contains()`. А удаление с помощью метода `remove()`. Например:

[source, java]
----
people.remove("Tom") // удаление элемента с данным значением из списка
people.remove(0) // удаление элемента на 0 позиции в списке
----

Получить определенный элемент по индексу мы можем с помощью метода `get()`, а установить элемент по индексу с помощью метода `set`. Например:

[source, java]
----
String person = people.get(1);
people.set(1, "Robert");
----

С помощью метода `toArray()` мы можем преобразовать список в массив объектов.

И поскольку класс `ArrayList` реализует интерфейс `Iterable`, то мы можем пробежаться по списку в цикле типа `for-each`:

[source, java]
----
for(String person : people) {
    // some opeartors
}
----

Хотя мы можем свободно добавлять в объект `ArrayList` дополнительные объекты, в отличие от массива, однако в реальности `ArrayList` использует для хранения объектов опять же массив. По умолчанию данный массив предназначен для 10 объектов. Если в процессе программы добавляется гораздо больше, то создается новый массив, который может вместить в себя все количество. Подобные перераспределения памяти *уменьшают производительность*. Поэтому если мы точно знаем, что у нас список не будет содержать больше определенного количества элементов, например, 25, то мы можем сразу же явным образом установить это количество, либо в конструкторе: `ArrayList<String> people = new ArrayList<String>(25);`, либо с помощью метода `ensureCapacity`: `people.ensureCapacity(25);`
