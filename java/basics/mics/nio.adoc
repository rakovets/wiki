= Java NIO

Java NIO (New IO) - это альтернативный API для работы с IO в Java (начиная с Java 1.4), это значит альтернативный стандартным Java IO и API Java Networking. Java NIO предлагает другой способ работы с IO, чем стандартный IO API.

*Java NIO: channels и buffers*

В стандартном IO API работают с потоками байт и потоками символов. В NIO работают с каналами и буферами. Данные всегда читаются из канала в буфер или записываются из буфера в канал.

*Java NIO: non-bloking IO*

Java NIO позволяет выполнять неблокирующие операции ввода-вывода. Например, поток может попросить канал прочитать данные в буфер. Пока канал читает данные в буфер, поток может делать что-то другое. Как только данные будут считаны в буфер, поток сможет продолжить их обработку. Аналогично и для записи данных в каналы.

*Java NIO: selectors*

Java NIO имеет понятие «селекторы». *Селектор* - это объект, который может отслеживать несколько каналов на наличие событий (например: соединение установлено, данные получены и т.д.). Таким образом, один поток может контролировать несколько каналов данных.

== Обзор Java NIO

*Java NIO* состоит из следующих основных компонентов:

* каналы
* буферы
* селекторы

Java NIO имеет не только эти компоненты, но фактически, `Channel`, `Buffer` и `Selector` являются ключевыми классами. Остальные компоненты, такие как `Pipe` и `FileLock` являются просто служебными классами, которые используются вместе с тремя основными компонентами.

=== Каналы и Буферы

Как правило, все операции ввода-вывода в NIO начинаются с `Channel`. `Channel` немного похож на `Stream`. Из `Channel` данные можно прочитать в `Buffer`. Данные также могут быть записаны из `Buffer` в `Channel`. :

image:/assets/img/java/basics/nio/channels-buffers.png[Java NIO: каналы и буферы]


Есть несколько `Channel` и `Buffer` типов. Ниже приведен список основных реализаций `Channel` в Java NIO:

* `FileChannel`
* `DatagramChannel`
* `SocketChannel`
* `ServerSocketChannel`

Эти каналы охватывают сетевой ввод-вывод по протоколам *UDP* и *TCP* и файловый ввод-вывод.

А вот список основных реализаций `Buffer` в Java NIO:

* `ByteBuffer`
* `CharBuffer`
* `DoubleBuffer`
* `FloatBuffer`
* `IntBuffer`
* `LongBuffer`
* `ShortBuffer`

Они `Buffer` охватывают основные типы данных, которые вы можете отправлять через IO:

* `char`
* `byte`
* `short`
* `int`
* `long`
* `float`
* `double`

Java NIO также имеет, `MappedByteBuffer` который используется для работы с отображением файлов в оперативной памяти.

=== Селекторы

`Selector` позволяет одному потоку обрабатывать несколько `Channel`. Это удобно, если в вашем приложении открыто много соединений (каналов), но каждое соединении имеет небольшой трафик. Например: сервер для чата.

Ниже приведенно изображение, того как `Thread` использует `Selector` для обработки 3 `Channel`:

image:/assets/img/java/basics/nio/selectors.png[Java NIO: селекторы]

Чтобы использовать, `Selector` необходимо зарегистрировать `Channel` с ним. Для этого используеют вызов метода `select()`. Этот метод будет заблокирован, пока не произойдет событие для одного из зарегистрированных каналов. Как только метод разблокируется, поток может обработать события. Примерами событий являются: входящее соединение, полученные данные и т.д.

== `Channel`

Каналы Java NIO похожи на потоки с некоторыми отличиями:

* можно читать/писать из/в каналы, а потоки обычно односторонние (чтение/запись)
* каналы могут быть прочитаны/записаны асинхронно
* каналы всегда читают/записывают из/в буфер

=== Реализация `Channel`

Вот наиболее важные реализации `Channel` в Java NIO:

* `FileChannel` - считывает данные из/в файла
* `DatagramChannel` - считывает/записывает данные по сети через *UDP*
* `SocketChannel` - считывает/записывает данные по сети через *TCP*
* `ServerSocketChannel` - прослушивает входящие соединения *TCP*, как это делает web-server, т.е. для каждого входящего соединения создается `SocketChannel`.

=== Пример основного канала

Вот базовый пример, в котором используется `FileChannel` для чтения некоторых данных в `Buffer`:

[source, java]
----
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {
    System.out.println("Read " + bytesRead);
    buf.flip();

    while(buf.hasRemaining()) {
        System.out.print((char) buf.get());
    }

    buf.clear();
    bytesRead = inChannel.read(buf);
}
aFile.close();
----

Обратите внимание на вызов `buf.flip()`. Сначала из канала считывают в буфер. Затем буфер переворачивают. После чего считывают из буффера.

== Buffers

Буферы используются при взаимодействии с каналами.

Буфер - это, по сути, блок памяти, в который можно записывать данные, которые затем можно снова прочитать. Этот блок памяти обернут в объект `Buffer`, который предоставляет набор методов, облегчающих работу с блоком памяти.

=== Основное использование буфера

Использование `Buffer` для чтения и записи данных обычно состоит из четырех шагов:

1. Записать данные в буфер
2. Вызов метода `buffer.flip()`
3. Чтение данных из буфера
4. Вызов одного из методов `buffer.clear()` или `buffer.compact()`

Когда данные записывают в буфер, буфер отслеживает, сколько данных записано. Когда нужно прочитать данные, тогда нужно переключить буфер из режима записи в режим чтения с помощью вызова метода `flip()`. В режиме чтения буфер позволяет читать все данные, записанные в буфер.

После того, как все данные были прочитаны, необходимо очистить буфер, чтобы он снова был готов к записи. Это можно сделать вызвав один из двух методов:

* `clear()` - метод очищает весь буфер
* `compact()` - метод удаляет только те данные, которые уже прочитали. Любые непрочитанные данные перемещаются в начало буфера, и теперь новые данные будут записываться в буфер после непрочитанных данных

Например:

[source, java]
----
RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");
FileChannel inChannel = aFile.getChannel();

//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {
    buf.flip();  //make buffer ready for read

    while(buf.hasRemaining()){
        System.out.print((char) buf.get()); // read 1 byte at a time
    }

    buf.clear(); //make buffer ready for writing
    bytesRead = inChannel.read(buf);
}
aFile.close();
----

=== Capacity, position и limit для буфера

У `Buffer` есть три поля, с которыми нужно ознакомиться, чтобы понять, как `Buffer` работает:

* `capacity`
* `position`
* `limit`

Значение `position` и `limit` зависит от того, `Buffer` находится ли режим чтения или записи. Емкость всегда означает одно и то же, независимо от режима буфера.

Вот иллюстрация емкости, положения и ограничения в режимах записи и чтения. Объяснение следует в разделах после иллюстрации.

image:/assets/img/java/basics/nio/buffers-modes.png[Java NIO: capacity, position, limit для буфера в режиме записи и чтения]

==== Capacity

Будучи блоком памяти, a `Buffer` имеет определенный фиксированный размер, в который можно записывать только байты, символы и т.д. Когда буфер заполнен, тогда нужно его очистить (прочитать или очистить данные), прежде чем иметь возможность записать в него больше данных.

==== Position

Когда данные записываются в `Buffer`, то это происходит с текущей `position`. Первоначально позиция равна `0`. Когда происходит запись одного байта, символа и т.д. в `Buffer` в текущую `position`, то она перемещается вперед, чтобы указывать на следующую ячейку в буфере, куда в дальнейшем будут записываться данные. Максимальное значение `position` может быть `capacity - 1`.

Когда данные из `Buffer` читаются, то это можно делать с текущей `position`. Когда `Buffer` переключается из режима записи в режим чтения, `position` сбрасывается обратно на `0`. При чтении данных из `Buffer`, они читаются с `position` и значение `position` изменяется на следующее.

==== Limit

В режиме записи `limit` для `Buffer` - это предел того, сколько данных можно записать в буфер. В режиме записи ограничение равно `capacity` для `Buffer`.

При переключении `Buffer` в режим чтения, `limit` означает предел того, сколько данных можно прочитать. Следовательно, при переключении `Buffer` в режим чтения `limit` задается равным `position` в режиме записи. Другими словами, можно прочитать столько байтов, сколько было записано.

=== Типы буфера

Java NIO содержит следующие типы буферов:

* `ByteBuffer`
* `MappedByteBuffer`
* `CharBuffer`
* `DoubleBuffer`
* `FloatBuffer`
* `IntBuffer`
* `LongBuffer`
* `ShortBuffer`

Эти типы `Buffer` представляют разные типы данных. Другими словами, они позволяют работать с байтами в буфере как `char`, `short`, `int`, `long`, `float` или `double`.

=== Создание буфера

У каждого `Buffer` класса есть `allocate()` метод, который создает объект `Buffer`. Например, создание `ByteBuffer` с `capacity` 48 байт:

[source, java]
----
ByteBuffer buf = ByteBuffer.allocate(48);
----

Например, создание `CharBuffer` с `capacity` для размещения 1024 символов:

[source, java]
----
CharBuffer buf = CharBuffer.allocate(1024);
----

=== Запись данных в буфер

Данные в буфер можно записать двумя способами:

* из `Channel` в `Buffer`
* используя `put()` методы класса `Buffer`

Пример, как с помощью `Channel` можно записывать данные в `Buffer`:

[source, java]
----
int bytesRead = inChannel.read(buf); // read into buffer
----

Пример, как с помощью метода `put()` класса `Buffer` можно записывать данные в него:

[source, java]
----
buf.put (127);
----

Существует много других версий метода `put()`, позволяющих записывать данные в `Buffer` различными способами. Например, запись в определенные позиции или запись массива байтов в буфер. Все это, можно посмотреть в *JavaDoc* для конкретной реализации буфера.

=== `flip()`

Метод `flip()` переключает `Buffer` из режима записи в режиме чтения. Вызов метода `flip()` устанавливает `position` обратно в `0` и устанавливает `limit` значение недавного `position`.

Другими словами, `position` теперь указывает на позицию чтения, а  `limit` показывает, сколько байт, символов и т.д. было записано в буфер.

=== Чтение данных из буфера

Есть два способа чтения данных из `Buffer`.

* из `Buffer` в `Channel`
* используя `get()` методы класса `Buffer`

Пример, как с помощью `Channel` можно читать данные из `Buffer`:

[source, java]
----
//read from buffer into channel.
int bytesWritten = inChannel.write(buf);
----

Пример, как с помощью метода `get()` класса `Buffer` можно читать данные из него:

[source, java]
----
byte aByte = buf.get();
----

Существует много других версий метода `get()`, позволяющих считывать данные из `Buffer` различными способами. Например, чтение из определенных позиций или чтение массива байт из буфера. Все это, можно посмотреть в *JavaDoc* для конкретной реализации буфера.

=== `rewind()`

`Buffer.rewind()` устанавливает в `position` значение `0`, так что можно было перечитать все данные в буфере. При этом `limit` не изменяется.

=== `clear()` и `compact()`

После прочтения данных из `Buffer`, его необходимо снова подготовиться к записи. Это можно сделать, вызвав методы `clear()` или `compact()`.

Если вызвать метод `clear()`, то `limit` станет равен значению `capacity`, a `position` станет `0`. Другими словами, `Buffer` очищается, но данные из него не удалены.

Если в момент вызова `clear()` были непрочитанные данные, то нельзя больше установить какие из них были прочитаны, а какие нет.

Если в `Buffer` все еще есть непрочитанные данные, и их необходимо прочитать позже, но перед этим нужно что-то еще записать в `Buffer`, тогда используют `compact()` вместо `clear()`.

Метод `compact()` копирует все непрочитанные данные в начало `Buffer`, а затем `position` устанавливается  сразу после последнего непрочитанного элемента. Для `limit` задается значение `capacity`, так же, как и для `clear()`. Теперь `Buffer` готов к записи и непрочитанные данные не будет перезаписываться.

=== `mark()` и `reset()`

Можно пометить данную позицию в `Buffer`, вызвав метод `Buffer.mark()`. Затем можно сбросить `position` обратно в помеченную позицию, вызвав метод `Buffer.reset()`. Вот пример:

[source, java]
----
buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset();  //set position back to mark.
----

=== `equals()` и `compareTo()`

Можно сравнить два буфера, используя `equals()` и `compareTo()`.

==== `equals()`

Два буфера равны, если:

* Они одного типа (байт, символ, int и т. Д.)
* Они имеют одинаковое количество оставшихся байтов, символов и т. Д. В буфере.
* Все остальные байты, символы и т. Д. Равны.
* Как вы можете видеть, функция equals сравнивает только часть `Buffer, а не каждый отдельный элемент. На самом деле, он просто сравнивает остальные элементы в `Buffer.

==== `compareTo()`

Метод `compareTo()` сравнивает остальные элементы (байты, символы и т.д.) из двух буферов, для использования, например, в подпрограммах сортировки. Буфер считается «меньшим», чем другой буфер, если:

* найден элемент, который отличается от соответствующего элемента из другого буфера, и он меньше его
* все элементы равны, но в первом буфере количество элементов меньше, чем во втором
