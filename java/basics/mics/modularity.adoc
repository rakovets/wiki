= Модульность (@since Java 9)

С выходом Java 9 появился новый уровень абстракции над пакетами, формально известный как *Java Platform Module System* (*JPMS*), или сокращенно *Modules*.

== Что такое модуль?

Прежде всего, нам нужно понять, что такое модуль, прежде чем его использовать.

*Модуль* - это группа тесно связанных *пакетов* и *ресурсов* вместе с новым типом файла *дескриптор модуля* (*module descriptor*).

Другими словами, это абстракция *пакет с Java-пакетами*, которая позволяет сделать наш код более пригодным для повторного использования.

=== Пакеты

Пакеты внутри модуля идентичны пакетам Java, которые Java поддерживает с момента создания.

Когда создается модуль (фактически: проект), то *код внутри организуется по пакетам, в зависимости от предназначения классов и связей между ними*.

Помимо организации нашего кода, пакеты используются для определения того, какой код является общедоступным за пределами модуля, т.е. определяется *API* для данного модуля.

=== Ресурсы

*Каждый модуль отвечает за свои ресурсы*, такие как медиа или конфигурационные файлы.

Ранешь их помещали в корневой уровень проекта и вручную управляли тем, какие ресурсы и к каким частям приложения относились.

С помощью модулей можно поставлять необходимые ресурсы вместе с тем модулем, которому они необходимые. Это значительно упрощает управление проектами.

=== Дескриптор модуля

При создании модуля в него включается *файл дескриптора*(*descriptor file*), который определяет несколько аспектов нового модуля:

* *Name* - название модуля
* *Dependencies*  - список модулей, от которых зависит этот модуль
* *Public Packages* - список всех пакетов, которые можно получить вне этого модуля
* *Services Offered* - предоставляет реализацию услуг (*implementation of service*), для использования другими модулями
* *Services Consumed* - использует реализацию услуг из другого модуля
* *Reflection Permissions* - позволяет другим классам использовать *Reflection API* для доступа к `private` членам данного модуля

Правила именования модулей похожи на правила именования пакетов (точки разрешены, а тире нет). Обычно используют имена в стиле:

* проекта (`my.module`)
* `Reverse-DNS` (`com.rakovets.mymodule`).

Необходимо помнить, что нужно перечислить все пакеты:

* которые будут общедоступными, потому что по умолчанию все пакеты являются *module private*
* для которых будет доступна *Reflection API*, по тому что по умолчанию нельзя использовать рефлексию для классов, которые импортируются из другого модуля

=== Типы модулей

В новой модульной системе есть четыре типа модулей:

* *System Modules*  - это модули Java SE и JDK, которые можно увидеть с помощью команды `java --list-modules`
* *Application Modules* - эти модули, которые необходимо использовать в текущем модуле. Они определены в скомпилированном  файле `module-info.class`, включенном в собранный JAR-file.
* *Automatic Modules* - это модули, которые включены в текущий неофициально, т.е. добавлением существующих JAR-файлов в путь к модулю. Название модуля будет производным от имени JAR-file. Эти модули будут иметь полный доступ для чтения ко всем аналогичным модулям
* *Unnamed Module*   - это универсальный модуль для обеспечения обратной совместимости с ранее написанным кодом Java. Он содержит классы или JAR-файлы загруженные в путь к классу, но не в путь к модулю

=== Распространение модуля

Модули, как и любой другой Java-проект, можно распространять в виде:

* JAR-файла
* «скомпонованного» скомпилированного проекта

Можно создавать многомодульные проекты, которые состоят из «основного приложения» и нескольких библиотечных модулей, но необходимо быть осторожны, потому что в JAR/project может быть только один модуль. Поэтому при настройке сборки (*build*), необходимо убедиться, что каждый модуль проекта упакован в отдельный JAR-файл.

== Модули по умолчанию

Когда мы устанавливаем Java 9, мы видим, что JDK теперь имеет новую структуру.

Они взяли все оригинальные пакеты и перенесли их в новую систему модулей.

Мы можем увидеть, что это за модули, набрав в командной строке:

[source, sh]
----
java --list-modules
----

Эти модули разделены на четыре основные группы:

* `java` - содержит модули являются классами реализации для основной спецификации языка SE
* `javafx` - содержит библиотеки пользовательского интерфейса FX
* `jdk` - содержит все, что необходимо JDK
* `oracle` - содержит проприетарный функционал от Oracle

== Объявления модуля

Чтобы создать модуль, нам нужно поместить специальный файл (*дескриптор модуля*/*module descriptor*) в корень наших пакетов с именем `module-info.java`. Он содержит всю информацию необходимую для построения и использования данного модуля.

Создание модуля с объявлением, тело которого либо пусто, либо содержит директивы модуля выглядит следующим образом:

[source, java]
----
module myModuleName {
    // all directives are optional
}
----

Объявление модуля начинается с ключевого слова `module`, далее указывается имя модуля. Этого достаточно для работы данного модуля, но обычно необходимо использовать другие модули и для этого существую *директивы*(*directives*) модуля.

=== Директива `requires`

Директива модуля `requires` позволяет объявлять зависимости модуля:

[source, java]
----
module my.module {
    requires module.name;
}
----

Теперь `my.module` имеет доступ во время кампиляции (*Compile-time*) и выполнение (*Runtime*) к зависимому модулю `module.name`. Все `public` типы из зависимого модуля, доступны в текущем модуле, благодаря использованию директивы `requires`.

=== Директива `requires static`

Иногда созданный модуль ссылается на другой модуль, но пользователи нашей библиотеки не хотят его использовать.

Например, написана служебная функция, которая красиво печатает внутреннее состояние наших объектов, когда есть зависимость от какого-то модуля логирования. Но не каждый потребитель нашей библиотеки захочет эту функциональность, и они не хотят включать дополнительную библиотеку логирорования.

В этих случаях можно использовать необязательную зависимость. Используя директиву `require static`, создается зависимость только во время компиляции:

[source, java]
----
module my.module {
    requires static module.name;
}
----

=== Директива `requires transitive`

В разработке часто используют сторонние библиотеки, чтобы сделать разработку проще. Но тогда нужно убедиться, что любой модуль, который будет использовать текущий модуль, также внесет эти дополнительные «транзитивные» зависимости, иначе модуль не будет работать.

Для этого можно использовать директиву `requires transitive`, чтобы заставить любых последующих потребителей использовать требуемые для текущего модуля зависимости:

[source, java]
----
module my.module {
    requires transitive module.name;
}
----

Теперь, когда кому-то необходим модуль `my.module`, то не требуется добавлять и `module.name` в зависимости для того, чтобы все работало корректно.

=== Директива `exports`

По умолчанию, модуль не предоставляет API другим модулям. Эта *сильная инкапсуляция*(*strong encapsulation*) являлась одним из ключевых факторов для создания модульной системы и это делает код значительно более безопасным, но теперь нужно явно открывать API для потребителей.

Что бы открыть API из конкретного пакета используется директива `exports`:

[source, java]
----
module my.module {
    exports com.my.package.name;
}
----

Теперь у потребителей `my.module`, будет доступ к `public` типам из пакета `com.my.package.name`, но не из любого другом.

=== Директива `export ... to`

С помощью директивы `export` можно открыть API для потребителя, но что, если нужно, чтобы не все имели доступ к нашему API?

Можно ограничить то, какие модули имеют доступ к API. Для этого используется директива `export ... to`.

Подобно директиве `export`, объявляется какой пакет экспортировать, но так же перечисляется, каким модулям разрешаем импортировать этот пакет:

[source, java]
----
module my.module {
    export com.my.package.name to com.specific.package;
}
----

=== Директива `uses`

*Сервис* обычно является реализацией определенного интерфейса или абстрактного класса, который может использоваться другими классами. Для обозначения сервисов, которые использует модуль, используется директива `uses`. Стоит обратить внимание, что в качестве имени класса мы используем интерфейс или абстрактный класс, который реализует *service*:

[source, java]
----
module my.module {
    uses class.name;
}
----

Следует отметить, что существует разница между директивой `requires` и директивой `uses`.Когда в модуле содержится сервис, который необходимо использовать, но этот сервис реализует интерфейс или абстрактный класс одной из своих транзитивных зависимостей, тогда вместо использования директивы `requires` для всех транзитивных зависимостей, используется директива `uses` для добавления необходимого интерфейса или абстрактного класса к модулю.

=== Директива `provides ... with`

Модуль может быть поставщиком сервиса, который могут использовать другие модули. Для данного случая применяют директиву `provides ... with`

Директива содержит ключевое слово `provides`, после чего указывается имя интерфейса или абстрактного класса. Далее следует `with`, после которого указывается имя класса реализации для интерфейса, либо наследника для абстрактного класса.

[source, java]
----
module my.module {
    provides MyInterface with MyInterfaceImpl;
}
----

=== Директива `open`

До Java 9 было возможно использовать *Reflection API* по отношению к любым классам, полям и методам, даже когда они имели модификатор доступа `private`, т.е. фактически реальной инкапсуляции небыло.

Поскольку Java 9 обеспечивает строгую инкапсуляцию, то теперь необходимо явно указать разрешение другим модулям использовать *Reflection API* по отношению к содержимому данного модулю.

[source, java]
----
open module my.module {
}
----

=== Директива `opens`

Если необходимо разрешить использовать *Reflection API*, но не для всего модуля, то используется директивa `opens`, которая предоставит эту возможность к определенному пакету.

[source, java]
----
module my.module {
  opens com.my.package;
}
----

=== Директива `opens ... to`

Если необходима более сильная инкапсуляция, то можно выборочно открывать пакеты для указанных модулей. Для этого используют  директиву `opens ... to`:

[source, java]
----
module my.module {
    opens com.my.package to moduleOne, moduleTwo, etc.;
}
----

== Параметры командной строки

В настоящее времени поддержка модулей Java 9 была добавлена ​​в *Maven* и *Gradle*, поэтому нет необходимости делать много ручной работы для сборки проектов. Однако полезно знать, как использовать систему модулей из командной строки. Для этого используют следующие параметры при работе в командной строке:

* `module-path` - используется для указания пути к модулю. Список из одного или нескольких директорий, которые содержат необходимые модули
* `add-reads` - объявляет зависимость от модуля (аналогично директиве `requires`)
* `add-exports` - предоставляет доступ к API (аналогично директиве `exports`)
* `add-opens` - разрешает прмменение *Reflection API* (аналогично директиве `open`)
* `add-modules` - добавляет список модулей в набор модулей по умолчанию
* `list-modules` - выводит список всех модулей и их версий
* `patch-module` - добавляет или переопределяет классы в модулях
* `illegal-access=permit|warn|deny` - либо ослабляет сильную инкапсуляцию показывая одно глобальное предупреждение, либо показывает каждое предупреждение, либо выдает ошибку (по умолчанию `permit`)

== Видимость

Многие библиотеки, что бы работать, зависят от возможности использования *Reflection API*, например: *JUnit* и *Spring*.

По умолчанию в Java 9 доступ предоставляется только к `public` классам, методам и полям в экспортируемых пакетах. Даже если использовать *reflection*, чтобы получить доступ к `private` членам с вызовом `setAccessible(true)`, то нельзя получить доступ к этим членам.

В таком случае можно использовать директивы `open`, `opens`, и `opens ... to` для предоставления доступа использовать *reflection* в *Runtime*. Однако не в *compile-time*.

Для этого у нас должен быть доступ к модулю. Когда же доступа к модулю нет (т.е. это сторонний модуль), тогда можно использовать параметр `-add-opens` в командной строке для предоставления доступа собственных модулей к инкапсулированному модулю в *Runtime*. Но необходимо помнить, что нужно иметь доступ к аргументам командной строки, которые используются для запуска модуля.

== Создание модуля с помощью CLI

=== Создание структуры проекта

Создадим несколько каталогов для организации файлов.

Создадим директорию с проектом:

[source, sh]
----
mkdir module-project
cd module-project
----

Это *root* директория проекта, поэтому она будет содержать в дальнейшем файлы сборки *Maven* или *Gradle*, другие *source* и *resource* директории.

Мы также поместили каталог для хранения всех модулей нашего проекта.

Далее создадим каталог модуля:

[source, sh]
----
mkdir simple-modules
----

Вот как будет выглядеть структура проекта:

[source, out]
----
module-project
|- // src if we use the default package
|- // build files also go at this level
+- simple-modules
  +- hello.modules
    +- com
      +- rakovets
        +- modules
          +- hello
  +- main.app
    +- com
      +- rakovets
        +- modules
          +- main
----

=== Первый модуль

Когда есть базовая структура, можно добавить первый модуль.

В директории `simple-modules` создадим новую директорию с именем `hello.modules` .

Ее можно назвать как угодно, но необходимо следовать правилам именования пакетов (т.е. точки для разделения пакетов и т.д.). Можно использовать имя основного пакета в качестве имени модуля, если необходимо, но обычно придерживаются того же имени, которое необходимо использовать при создании JAR-файла этого модуля.

В новом модуле можно создавать нужные пакеты. В текущем случае создим следующую структуру пакета:

[source, out]
----
com.rakovets.modules.hello
----

Затем в этом пакете создадим новый класс с именем `HelloModules.java`. Этот клас будет содержать очень простой код:

[source, java]
----
package com.rakovets.modules.hello;

public class HelloModules {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }
}
----

Затем в корневой директори `hello.modules` добавим дескриптор модуля `module-info.java`:

[source, java]
----
module hello.modules {
    exports com.rakovets.modules.hello;
}
----

Для простоты только экспортируем все открытые члены пакета `com.rakovets.modules.hello`.

=== Второй модуль

Первый самостоятельно ничего не делает. Создадим второй модуль, который будет использовать функционал первого.

В директории `simple-modules` создадим еще одну директорию для модуля с именем `main.app` и добавим дескриптор модуля:

[source, java]
----
module main.app {
    requires hello.modules;
}
----

Второй модуль не будет предоставлять API, он только будет использовать первый модуль.

Для этого создадим новую структуру пакетов `com.rakovets.modules.main`.

Затем создадим новый файл класса с именем `MainApp.java`.

[source, java]
----
package com.rakovets.modules.main;

import com.rakovets.modules.hello.HelloModules;

public class MainApp {
    public static void main(String[] args) {
        HelloModules.doSomething();
    }
}
----

Это продемонстрирует принцип создания модулей.

=== Сборка модулей

Что бы сделать `build` проекта, можно создать bash-скрипт и поместить его в корень проекта.

Создадим файл с именем `compile-simple-modules.sh`:

[source, sh]
----
#!/usr/bin/env bash
javac -d outDir --module-source-path simple-modules $(find simple-modules -name "*.java")
----

Команда состоит из двух команд:

* `javac` - компилирует все java-файлы, которые были найдены с помощью команды `find`
* `find` - выводит список всех java-файлов в директории `simple-modules`

Единственное отличие от более старых версий Java, это необходимость предоставить параметр `module-source-path`, чтобы сообщить компилятору о том, что он делает `build` модулей.

Как только команда будет запущена, появится директория `outDir` с двумя скомпилированными модулями внутри.

=== Запуск

Что бы проверить работоспособность модулей необходимо запусти проект.

Создадим bash-скрипт в корне проекта `run-simple-module-app.sh:

[source, sh]
----
#!/usr/bin/env bash
java --module-path outDir -m main.app/com.rakovets.modules.main.MainApp
----

Чтобы запустить модуль, необходимо указать путь к модулю и основному классу. Запустим и если все верно, то увидим:

[source, sh]
----
./run-simple-module-app.sh
Hello, Modules!
----

=== Добавление сервиса

Усложним проект, добавив в него `service`. Для этого используем директивы:

* `provides…with`
* `uses`

Определим новый файл в модуле `hello.modules` с именем `HelloInterface.java`:

[source, java]
----
public interface HelloInterface {
    void sayHello();
}
----

Реализуем интерфейс в существующем классе `HelloModules.java`:

[source, java]
----
public class HelloModules implements HelloInterface {
    public static void doSomething() {
        System.out.println("Hello, Modules!");
    }

    public void sayHello() {
        System.out.println("Hello!");
    }
}
----

Необходимый `service` создан. Теперь необходимо указать что модуль предоставляет этот `service`. Для этого добавим в `module-info.java` следующее:

[source, java]
----
provides com.rakovets.modules.hello.HelloInterface with com.rakovets.modules.hello.HelloModules;
----

Т.е. объявили интерфейс и класс, который его реализует.

В модуле `main.app`, для использования этого `service` нужно добавить следующее в `module-info.java`:

[source, java]
----
uses com.rakovets.modules.hello.HelloInterface;
----

Теперо в `main` методе можно использовать этот `service`:

[source, java]
----
HelloModules module = new HelloModules();
module.sayHello();
----

Компилируем и запускаем:

[source, sh]
----
./run-simple-module-app.sh
Hello, Modules!
Hello!
----

Так же можно поместить реализацию в приватный пакет, а интерфейс в публичный пакет. Это сделает наш код более безопасным при минимальных усилиях.

== Добавление модулей в *Unnamed Module*

Концепция *Unnamed Module* похожа на пакет по умолчанию, поэтому его не следует считать реальным модулем, но можно рассматриваться как модуль по умолчанию.

Если класс не является членом других типов модулей, то он будет автоматически рассматриваться как часть *Unnamed Module*.

Иногда, чтобы обеспечить наличие определенных модулей платформы, библиотеки или поставщика услуг в графе модулей, нужно добавить модули в набор по умолчанию. Например, когда пытаемся работать с программами на Java 8 используя компилятор Java 9, тогда может потребоваться добавить модули.

Возможность добавления именованных модулей в набор корневых модулей по умолчанию выглядит  `-add-modules <module>, ..., <module>`,  где `<module>` - это имя модуля.

Например, чтобы обеспечить доступ всех модулей к модулю `java.xml.bind`, синтаксис должен быть следующим:

[source, sh]
----
--add-modules java.xml.bind
----

Чтобы использовать это с помощью *Maven*, необходимо добавит это в конфигурацию для `maven-compiler-plugin`:

[source, xml]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.8.0</version>
    <configuration>
        <source>9</source>
        <target>9</target>
        <compilerArgs>
            <arg>--add-modules</arg>
            <arg>java.xml.bind</arg>
        </compilerArgs>
    </configuration>
</plugin>
----
