== Многопоточное программирование

Большинство языков программирования поддерживают такую важную функциональность как многопоточность, и Java в этом плане не исключение. При помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. Если у нас, допустим, графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому большинство реальных приложений, которые многим из нас приходится использовать, практически не мыслимы без многопоточности.

=== Класс `Thread`

В Java функциональность отдельного потока заключается в классе `Thread`. И чтобы создать новый поток, нам надо создать объект этого класса. Но все потоки не создаются сами по себе. Когда запускается программа, начинает работать *главный поток* этой программы. От этого главного потока порождаются все остальные *дочерние потоки*.

С помощью статического метода `Thread.currentThread()` мы можем получить текущий поток выполнения:

[source, java]
----
public static void main(String[] args) {
    Thread t = Thread.currentThread(); // получаем главный поток
    System.out.println(t.getName()); // main
}
----

По умолчанию именем главного потока будет `main`.

Для управления потоком класс `Thread` предоставляет еще ряд методов. Наиболее используемые из них:

- `getName()` возвращает имя потока
- `setName(String name)` устанавливает имя потока
- `getPriority()` возвращает приоритет потока
- `setPriority(int proirity)` устанавливает приоритет потока. Приоритет является одним из ключевых факторов для выбора системой потока из кучи потоков для выполнения. В этот метод в качестве параметра передается числовое значение приоритета - от `1` до `10`. По умолчанию главному потоку выставляется средний приоритет - `5`.
- `isAlive()` возвращает `true`, если поток активен
- `isInterrupted()` возвращает `true`, если поток был прерван
- `join()` ожидает завершение потока
- `run()` определяет точку входа в поток
- `sleep()` приостанавливает поток на заданное количество миллисекунд
- `start()` запускает поток, вызывая его метод `run()`

Мы можем вывести всю информацию о потоке:

[source, java]
----
public static void main(String[] args) {
    Thread t = Thread.currentThread(); // получаем главный поток
    System.out.println(t); // Thread[main,5,main]
}
----

Первое `main` будет представлять имя потока (что можно получить через `t.getName()`), второе значение `5` предоставляет приоритет потока (также можно получить через `t.getPriority()`), и последнее `main` представляет имя группы потоков, к которому относится текущий - по умолчанию также `main` (также можно получить через `t.getThreadGroup().getName()`)

=== Недостатки при использовании потоков

Далее мы рассмотрим, как создавать и использовать потоки. Это довольно легко. Однако при создании многопоточного приложения нам следует учитывать ряд обстоятельств, которые негативно могут сказаться на работе приложения.

На некоторых платформах запуск новых потоков может замедлить работу приложения. Что может иметь большое значение, если нам критичная производительность приложения.

*Для каждого потока создается свой собственный стек в памяти*, куда помещаются все локальные переменные и ряд других данных, связанных с выполнением потока. Соответственно, чем больше потоков создается, тем больше памяти используется. При этом надо помнить, в любой системе размеры используемой памяти ограничены. Кроме того, во многих системах может быть ограничение на количество потоков. Но даже если такого ограничения нет, то в любом случае имеется естественное ограничение в виде максимальной скорости процессора.
